# data/ingestion/__init__.py
from .mexc_websocket_connector import MexcWebsocketConnector
from .websocket_manager import WebSocketManager

__all__ = ['MexcWebsocketConnector', 'WebSocketManager']

# data/ingestion/mexc_data_ingestion.py
import asyncio
import json
import logging
import os
import time
from typing import Dict, Any, Optional, List
from asyncio import Queue
from contextlib import suppress
import websockets
import uuid
from dotenv import load_dotenv
import numpy as np  # Import NumPy for TA-Lib
import talib

from ..config import Config
from .websocket_handler import WebSocketHandler
from ..processing.data_processor import DataProcessor
from models.gmn.indicators import IndicatorFactory  # Or wherever you place it

load_dotenv()


class DataIngestion:
    """Handles the ingestion of data from the MEXC WebSocket API."""

    def __init__(self, gmn: Any, config: Config):
        self.gmn = gmn
        self.config = config
        self.ws_url = os.getenv('MEXC_WS_URL', 'wss://wbs.mexc.com/ws')
        self.api_key = os.getenv('MEXC_API_KEY')
        self.api_secret = os.getenv('MEXC_API_SECRET')
        self.websocket_handler = WebSocketHandler(
            self.ws_url, self.api_key, self.api_secret, config.rate_limit, config=config
        )
        self.data_processor = DataProcessor(gmn)
        self.processing_queue: Queue[Dict[str, Any]] = asyncio.Queue(
            maxsize=config.processing_queue_size
        )

        self.reconnect_attempts = 0
        self.max_reconnect_attempts = config.max_reconnect_attempts
        self.backoff_factor = config.backoff_factor
        self._batch_task: Optional[asyncio.Task] = None
        self._receiving_task: Optional[asyncio.Task] = None
        self._last_reconnect_time = 0

        # Initialize the IndicatorFactory
        self.indicator_factory = IndicatorFactory()
        # Create dictionaries to store price data for TA calculations
        self.price_data: Dict[str, List[float]] = {
            timeframe: [] for timeframe in self.config.timeframes
        }

    async def connect(self):
        """Connects to the WebSocket and handles reconnections with backoff."""

        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                async with self.websocket_handler as ws:
                    if self.reconnect_attempts > 0:
                        logging.info("Reconnection successful.")

                    self.reconnect_attempts = 0
                    await self._login(ws)
                    await self._subscribe(ws)

                    self._batch_task = asyncio.create_task(self._batch_processor())
                    self._receiving_task = asyncio.create_task(
                        self._receive_data_loop(ws)
                    )

                    await self._batch_task
                    await self._receiving_task
            except (
                websockets.exceptions.ConnectionClosedError,
                websockets.exceptions.ConnectionClosedOK,
                ConnectionResetError,
                OSError,
                asyncio.TimeoutError,
            ) as e:
                logging.error(f"WebSocket connection error: {e}")
            except Exception as e:
                logging.exception(f"An unexpected error occurred: {e}")
            finally:
                pass

            current_time = time.monotonic()
            backoff_delay = self.config.reconnect_delay * (
                self.backoff_factor ** self.reconnect_attempts
            )
            jitter = backoff_delay * 0.2  # Add some random variation
            wait_time = min(backoff_delay + jitter, self.config.max_reconnect_delay)
            next_reconnect = self._last_reconnect_time + wait_time
            sleep_duration = max(0, next_reconnect - current_time)
            logging.info(
                f"Next reconnection attempt in {sleep_duration:.2f} seconds..."
            )
            await asyncio.sleep(sleep_duration)
            self._last_reconnect_time = time.monotonic()
            self.reconnect_attempts += 1

    async def _login(self, ws):
        if self.api_key and self.api_secret:
            timestamp = int(time.time())
            sign_params = {'api_key': self.api_key, 'req_time': timestamp}
            signature = self.websocket_handler._generate_signature(sign_params)
            login_params = {
                'method': 'server.auth',
                'params': [self.api_key, timestamp, signature],
                'id': 1,
            }
            await self.websocket_handler.send_message(json.dumps(login_params), ws)
            response = await self.websocket_handler.receive_message(ws)
            if response:
                response_data = json.loads(response)
                if response_data.get('result') == 'success':
                    logging.info("WebSocket login successful.")
                else:
                    logging.error("WebSocket login failed.")
            else:
                logging.error("No response received during WebSocket login.")

    async def _subscribe(self, ws):
        for timeframe in self.config.timeframes:
            kline_channel = f"sub.kline.{self.config.symbol}.{timeframe}"
            subscribe_message = {'method': kline_channel, 'params': [], 'id': 1}
            await self.websocket_handler.send_message(
                json.dumps(subscribe_message), ws
            )

        for channel in self.config.private_channels:
            subscribe_message = {'method': f"sub.{channel}", 'params': [], 'id': 1}
            await self.websocket_handler.send_message(
                json.dumps(subscribe_message), ws
            )

    async def _receive_data_loop(self, ws):
        while True:
            try:
                message = await self.websocket_handler.receive_message(ws)
                if message:
                    try:
                        data = json.loads(message)
                        if "c" in data and data["c"].startswith(
                            "spot@public.kline.v3.api@"
                        ):
                            await self._process_kline_data(data)
                        else:
                            await self.processing_queue.put(
                                data
                            )  # For other messages
                    except json.JSONDecodeError as e:
                        logging.error(
                            f"Failed to decode JSON message: {e}. Message: {message}"
                        )
            except asyncio.CancelledError:
                logging.info("Receive data loop cancelled.")
                break
            except websockets.exceptions.ConnectionClosedOK as e:
                logging.warning(f"WebSocket closed gracefully: {e.reason}")
                break
            except websockets.exceptions.ConnectionClosedError as e:
                logging.error(f"WebSocket closed with error: {e.reason}")
                break
            except Exception as e:
                logging.exception(f"Error in receive_data_loop: {e}")
                break

    async def _process_kline_data(self, data: Dict[str, Any]):
        """Processes kline data and calculates indicators."""
        channel = data["c"]
        kline_data = data["d"]["k"]
        timeframe = channel.split("@")[-1]  # Extract timeframe
        close_price = float(kline_data['c'])

        # Update price data for the timeframe
        self.price_data[timeframe].append(close_price)

        # Calculate indicators
        prices_array = np.array(self.price_data[timeframe], dtype=np.float64)
        calculated_indicators = {}
        if len(prices_array) >= 14:
            for indicator_name in self.config.indicators:
                indicator_func = getattr(
                    self.indicator_factory, f"create_{indicator_name}", None
                )
                if indicator_func:
                    try:
                        indicator_value = indicator_func()(prices_array)
                        calculated_indicators[indicator_name] = indicator_value
                    except Exception as e:
                        logging.error(f"Error calculating {indicator_name}: {e}")

        # Update the GMN with the kline data and calculated indicators
        await self.gmn.update_graph(
            {
                "timeframe": timeframe,
                "close": close_price,
                "volume": float(kline_data['v']),
                **calculated_indicators,  # Add the calculated indicators
            }
        )

    async def _batch_processor(self, batch_size=100, timeout=0.5):
        message_retry_counts = {}

        while True:
            batch = []
            try:
                for _ in range(batch_size):
                    try:
                        message = await asyncio.wait_for(
                            self.processing_queue.get(), timeout
                        )
                        batch.append(message)
                        self.processing_queue.task_done()
                    except asyncio.TimeoutError:
                        break
                    except asyncio.CancelledError:
                        logging.info("Batch processor inner loop cancelled.")
                        raise
                if batch:
                    try:
                        await self.data_processor.process_data(batch)
                        for message_data in batch:
                            message_id = self._get_message_id(message_data)
                            message_retry_counts.pop(message_id, None)  # Remove if successful
                    except Exception as e:
                        logging.exception(f"Error processing batch: {e}")
                        for message_data in batch:
                            message_id = self._get_message_id(message_data)
                            retry_count = message_retry_counts.get(message_id, 0) + 1
                            if retry_count <= self.config.max_retry_attempts:
                                message_retry_counts[message_id] = retry_count
                                await self.processing_queue.put(message_data)
                            else:
                                logging.error(
                                    f"Message {message_id} exceeded retry limit. Discarding."
                                )
            except asyncio.CancelledError:
                logging.info("Batch processor task cancelled.")
                break

    def _get_message_id(self, message: Dict[str, Any]) -> str:
        """Generates or extracts a unique ID for the message."""
        try:
            message_id = message.get('id')
            if message_id:
                return str(message_id)  # Return if present and valid
        except (TypeError, ValueError):  # Handle potential errors
            pass

        message_id = (
            uuid.uuid4()
        )  # Generate UUID if 'id' is not present or invalid
        logging.debug(
            f"Generated UUID {message_id} for message (it didn't have a valid ID)"
        )  # Log UUID generation
        return str(message_id)

    async def close(self):
        """Closes the WebSocket connection and tasks."""
        tasks = [
            self._batch_task,
            self._receiving_task,
        ]  # Include _receiving_task
        for task in tasks:
            if task:
                task.cancel()
                with suppress(asyncio.CancelledError):
                    await task
        await self.websocket_handler.close()

        # data/ingestion/mexc_websocket_connector.py
import asyncio
import json
import logging
import os
import time
from typing import Dict, Any, Optional, List
from asyncio import Queue, Event
from contextlib import suppress
import websockets
import uuid
from dotenv import load_dotenv

from ..config import Config
from .websocket_manager import WebSocketManager  # Correct import

load_dotenv()

class MexcWebsocketConnector: 
    """Connects to the MEXC WebSocket API, handles subscriptions, 
       and passes raw data to a processing queue.
    """

    def __init__(self, config: Config, data_queue: asyncio.Queue):
        self.config = config
        self.data_queue = data_queue 

        self.ws_url = os.getenv("MEXC_WS_URL", "wss://wbs.mexc.com/ws")
        self.api_key = os.getenv("MEXC_API_KEY")
        self.api_secret = os.getenv("MEXC_API_SECRET")
        self.websocket_manager = WebSocketManager(
            self.ws_url, self.api_key, self.api_secret, config.rate_limit, config=config
        )  

        self.reconnect_attempts = 0
        self.max_reconnect_attempts = config.max_reconnect_attempts
        self.backoff_factor = config.backoff_factor
        self._last_reconnect_time = 0

        self.connected_event = Event()

    async def connect(self):
        """Connects to the WebSocket and handles reconnections with backoff."""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                async with self.websocket_manager as ws: 
                    if self.reconnect_attempts > 0:
                        logging.info("Reconnection successful.")
                    self.reconnect_attempts = 0
                    self.connected_event.set() 

                    await self._login(ws)
                    await self._subscribe(ws)
                    await self._receive_data_loop(ws)

            except (
                websockets.exceptions.ConnectionClosedError,
                websockets.exceptions.ConnectionClosedOK,
                ConnectionResetError,
                OSError,
                asyncio.TimeoutError,
            ) as e:
                logging.error(f"WebSocket connection error: {e}")
            except Exception as e:
                logging.exception(f"An unexpected error occurred: {e}")
            finally:
                self.connected_event.clear()  

            current_time = time.monotonic()
            backoff_delay = self.config.reconnect_delay * (
                self.backoff_factor ** self.reconnect_attempts
            )
            jitter = backoff_delay * 0.2 
            wait_time = min(backoff_delay + jitter, self.config.max_reconnect_delay)
            next_reconnect = self._last_reconnect_time + wait_time
            sleep_duration = max(0, next_reconnect - current_time)
            logging.info(
                f"Next reconnection attempt in {sleep_duration:.2f} seconds..."
            )
            await asyncio.sleep(sleep_duration)
            self._last_reconnect_time = time.monotonic()
            self.reconnect_attempts += 1

    async def _login(self, ws):
        if self.api_key and self.api_secret:
            timestamp = int(time.time())
            sign_params = {'api_key': self.api_key, 'req_time': timestamp}
            signature = self.websocket_manager._generate_signature(sign_params)
            login_params = {
                'method': 'server.auth',
                'params': [self.api_key, timestamp, signature],
                'id': 1,
            }
            await self.websocket_manager.send_message(json.dumps(login_params), ws)
            response = await self.websocket_manager.receive_message(ws)
            if response:
                response_data = json.loads(response)
                if response_data.get('result') == 'success':
                    logging.info("WebSocket login successful.")
                else:
                    logging.error("WebSocket login failed.")
            else:
                logging.error("No response received during WebSocket login.")

    async def _subscribe(self, ws):
        for timeframe in self.config.timeframes:
            kline_channel = f"sub.kline.{self.config.symbol}.{timeframe}"
            subscribe_message = {'method': kline_channel, 'params': [], 'id': 1}
            await self.websocket_manager.send_message(
                json.dumps(subscribe_message), ws
            )

        for channel in self.config.private_channels:
            subscribe_message = {'method': f"sub.{channel}", 'params': [], 'id': 1}
            await self.websocket_manager.send_message(
                json.dumps(subscribe_message), ws
            )

    async def _receive_data_loop(self, ws):
        while True:
            try:
                message = await ws.receive_message()
                if message:
                    try:
                        data = json.loads(message)
                        await self.data_queue.put(data)
                    except json.JSONDecodeError as e:
                        logging.error(
                            f"Failed to decode JSON message: {e}. Message: {message}"
                        )
            except asyncio.CancelledError:
                logging.info("Receive data loop cancelled.")
                break
            except websockets.exceptions.ConnectionClosedOK as e:
                logging.warning(f"WebSocket closed gracefully: {e.reason}")
                break
            except websockets.exceptions.ConnectionClosedError as e:
                logging.error(f"WebSocket closed with error: {e.reason}")
                break
            except Exception as e:
                logging.exception(f"Error in receive_data_loop: {e}")
                break

    async def close(self):
        await self.websocket_manager.close()

        # tests/test_websocket_handler.py
import asyncio
import json
import pytest
from unittest.mock import AsyncMock, patch

# Make sure to import from the correct location:
from data.ingestion.websocket_handler import WebSocketHandler 

class MockWebSocket:
    def __init__(self, messages=None):
        self.messages = messages if messages else []
        self.sent_messages = []
        self.closed = False

    async def recv(self):
        if self.messages:
            return json.dumps(self.messages.pop(0))
        else:
            await asyncio.sleep(0.1)
            return None

    async def send(self, message):
        self.sent_messages.append(message)

    async def close(self):
        self.closed = True

    async def ping(self):
        pass

    async def pong(self):
        pass

@pytest.mark.asyncio
async def test_connect_and_subscribe():
    """Tests connecting to a mock WebSocket and subscribing to a channel."""
    mock_ws = MockWebSocket()
    with patch('websockets.connect', new_callable=AsyncMock) as mock_connect:
        mock_connect.return_value = mock_ws
        handler = WebSocketHandler("wss://test-ws.com", "test_api_key", "test_api_secret", 10)
        
        async with handler: 
            assert handler.websocket is not None
            assert handler.websocket.closed is False

            await handler.subscribe_to_spot("BTCUSDT")

            expected_message = json.dumps({
                "method": "SUBSCRIPTION",
                "params": ["spot@public.deals.v3.api@BTCUSDT"]
            })
            assert expected_message in mock_ws.sent_messages