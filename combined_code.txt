#data\__init__.py
from .config import Config
from .mexc_websocket_connector import MexcWebsocketConnector
from .data_processor import DataProcessor
from .websocket_manager import WebSocketManager

__all__ = ['Config', 'MexcWebsocketConnector', 'DataProcessor', 'WebSocketManager']

#data\config.py

from typing import List, Dict, Any, Union, Optional
from pydantic import BaseSettings, validator, PositiveInt, Field


class Config(BaseSettings):
    """Configuration settings for data ingestion and processing."""

    symbol: str = "BTC_USDT"
    timeframes: List[str] = ["1m", "5m"]
    private_channels: List[Union[str, Dict[str, Any]]] = Field(default_factory=list)
    indicators: Dict[str, Any] = Field(default_factory=dict)
    reconnect_delay: PositiveInt = 5
    max_reconnect_delay: PositiveInt = 300
    backoff_factor: float = 2.0
    rate_limit: PositiveInt = 100
    processing_queue_size: PositiveInt = 1000
    max_reconnect_attempts: int = 10
    max_retry_attempts: int = 3

    class Config:
        env_file = '.env'
        env_file_encoding = 'utf-8'

    @validator('timeframes', pre=True)
    def validate_timeframes(cls, v):
        if isinstance(v, str):
            return [tf.strip() for tf in v.split(',')]
        elif isinstance(v, list):
            return v
        else:
            raise ValueError("Timeframes must be a comma-separated string or a list.")

    def get_indicator_param(
        self, indicator_name: str, param_name: str, default_value: Optional[Any] = None
    ) -> Any:
        return self.indicators.get(f"{indicator_name}_{param_name}", default_value)

    def get_rsi_timeperiod(self) -> int:
        return self.get_indicator_param("rsi", "timeperiod", 14)

    def get_macd_fastperiod(self) -> int:
        return self.get_indicator_param("macd", "fastperiod", 12)

    def get_macd_slowperiod(self) -> int:
        return self.get_indicator_param("macd", "slowperiod", 26)

    def get_macd_signalperiod(self) -> int:
        return self.get_indicator_param("macd", "signalperiod", 9)

    def get_fibonacci_lookback(self) -> int:
        return self.get_indicator_param("fibonacci", "lookback", 14)
#data\data_processor.py

import logging
from typing import Dict, Any, List


class DataProcessor:
    """Processes incoming data and updates the Graph Management Node (GMN)."""

    def __init__(self, gmn):
        self.gmn = gmn

    async def process_data(self, data_batch: List[Dict[str, Any]]):
        """Processes a batch of data messages."""
        for data in data_batch:
            try:
                if 'data' in data and 'channel' in data:
                    channel = data['channel']
                    if channel.startswith('push.kline'):
                        await self._process_kline_data(data)
                    elif channel.startswith("push.private."):
                        await self._process_private_data(data)
                elif 'method' in data:
                    self._process_method_data(data)
            except Exception as e:
                logging.exception(f"Error processing data: {e}")

    async def _process_kline_data(self, data: Dict[str, Any]):
        """Processes kline (candlestick) data."""
        channel_parts = data['channel'].split('.')
        if len(channel_parts) >= 4:
            interval = channel_parts[3]
            kline_data = data['data']

            if not kline_data:
                logging.warning("Kline data is None or empty. Skipping.")
                return

            if isinstance(kline_data, list):  # Batch of klines
                for kline in kline_data:
                    kline['interval'] = interval
                await self.gmn.update_graph(kline_data)
            elif isinstance(kline_data, dict):  # Single kline
                kline_data['interval'] = interval
                await self.gmn.update_graph([kline_data])
            else:
                logging.error(
                    f"Unexpected kline data type: {type(kline_data)}. Data: {kline_data}"
                )
        else:
            logging.warning(f"Unexpected channel format: {data['channel']}")

    async def _process_private_data(self, data: Dict[str, Any]):
        """Processes private channel data."""
        channel = data.get("channel")
        if channel == 'push.account':
            logging.info(f"Account Update: {data['data']}")
        elif channel == 'push.order':
            logging.info(f"Order Update: {data['data']}")
        else:
            logging.warning(
                f"Unhandled private channel: {channel}. Data: {data.get('data')}"
            )

    def _process_method_data(self, data: Dict[str, Any]):
        """Processes method-based data."""
        method = data.get('method')
        if method == 'pong':
            logging.debug("Received pong from server.")
        elif method and method.startswith('sub'):
            logging.info(f"Subscribed to channel: {method}")
        elif method and method.startswith('unsub'):
            logging.info(f"Unsubscribed from channel: {method}")
        else:
            logging.debug(f"Unhandled method message: {method}")
#data\mexc_websocket_connector.py
import asyncio
import json
import logging
import os
import time
from typing import Dict, Any
from asyncio import Queue
from dotenv import load_dotenv
import websockets

from .config import Config
from .websocket_manager import WebSocketManager  # Corrected import

load_dotenv()


class MexcWebsocketConnector:
    """
    Connects to the MEXC WebSocket API, handles subscriptions,
    and passes raw data to a processing queue.
    """

    def __init__(self, config: Config, data_queue: Queue):
        self.config = config
        self.data_queue = data_queue
        self.ws_url = os.getenv("MEXC_WS_URL", "wss://wbs.mexc.com/ws")
        self.api_key = os.getenv("MEXC_API_KEY")
        self.api_secret = os.getenv("MEXC_API_SECRET")
        self.websocket_manager = WebSocketManager(
            self.ws_url, self.api_key, self.api_secret, config.rate_limit, config=config
        )

        self.reconnect_attempts = 0
        self._last_reconnect_time = 0
        self.connected_event = asyncio.Event()

    async def connect(self):
        """Connects to the WebSocket and handles reconnections with backoff."""
        while self.reconnect_attempts < self.config.max_reconnect_attempts:
            try:
                async with self.websocket_manager as ws:
                    if self.reconnect_attempts > 0:
                        logging.info("Reconnection successful.")
                    self.reconnect_attempts = 0
                    self.connected_event.set()

                    await self._login(ws)
                    await self._subscribe(ws)
                    await self._receive_data_loop(ws)

            except (
                websockets.exceptions.ConnectionClosedError,
                websockets.exceptions.ConnectionClosedOK,
                ConnectionResetError,
                OSError,
                asyncio.TimeoutError,
            ) as e:
                logging.error(f"WebSocket connection error: {e}")
            except Exception as e:
                logging.exception(f"An unexpected error occurred: {e}")
            finally:
                self.connected_event.clear()

            await self._handle_reconnection_delay()

    async def _login(self, ws):
        if self.api_key and self.api_secret:
            timestamp = int(time.time())
            sign_params = {'api_key': self.api_key, 'req_time': timestamp}
            signature = self.websocket_manager._generate_signature(sign_params)
            login_params = {
                'method': 'server.auth',
                'params': [self.api_key, timestamp, signature],
                'id': 1,
            }
            await self.websocket_manager.send_message(json.dumps(login_params), ws)
            response = await self.websocket_manager.receive_message(ws)
            if response:
                response_data = json.loads(response)
                if response_data.get('result') == 'success':
                    logging.info("WebSocket login successful.")
                else:
                    logging.error("WebSocket login failed.")
            else:
                logging.error("No response received during WebSocket login.")

    async def _subscribe(self, ws):
        for timeframe in self.config.timeframes:
            kline_channel = f"sub.kline.{self.config.symbol}.{timeframe}"
            subscribe_message = {'method': kline_channel, 'params': [], 'id': 1}
            await self.websocket_manager.send_message(
                json.dumps(subscribe_message), ws
            )

        for channel in self.config.private_channels:
            subscribe_message = {'method': f"sub.{channel}", 'params': [], 'id': 1}
            await self.websocket_manager.send_message(
                json.dumps(subscribe_message), ws
            )

    async def _receive_data_loop(self, ws):
        while True:
            try:
                message = await self.websocket_manager.receive_message(ws)
                if message:
                    try:
                        data = json.loads(message)
                        await self.data_queue.put(data)
                    except json.JSONDecodeError as e:
                        logging.error(
                            f"Failed to decode JSON message: {e}. Message: {message}"
                        )
            except asyncio.CancelledError:
                logging.info("Receive data loop cancelled.")
                break
            except websockets.exceptions.ConnectionClosedOK as e:
                logging.warning(f"WebSocket closed gracefully: {e.reason}")
                break
            except websockets.exceptions.ConnectionClosedError as e:
                logging.error(f"WebSocket closed with error: {e.reason}")
                break
            except Exception as e:
                logging.exception(f"Error in receive_data_loop: {e}")
                break

    async def _handle_reconnection_delay(self):
        """Handles the delay before attempting to reconnect."""
        current_time = time.monotonic()
        backoff_delay = self.config.reconnect_delay * (
            self.config.backoff_factor ** self.reconnect_attempts
        )
        jitter = backoff_delay * 0.2  # 20% jitter
        wait_time = min(backoff_delay + jitter, self.config.max_reconnect_delay)
        next_reconnect = self._last_reconnect_time + wait_time
        sleep_duration = max(0, next_reconnect - current_time)
        logging.info(
            f"Next reconnection attempt in {sleep_duration:.2f} seconds..."
        )
        await asyncio.sleep(sleep_duration)
        self._last_reconnect_time = time.monotonic()
        self.reconnect_attempts += 1

    async def close(self):
        """Closes the WebSocket connection."""
        await self.websocket_manager.close()
#data\websocket_manager.py
import asyncio
import hashlib
import hmac
import time
import logging
from typing import Any, Optional, Dict
import websockets
from websockets.client import WebSocketClientProtocol
import asyncio
import json
import logging
import os
import time
from typing import Dict, Any
from asyncio import Queue
from dotenv import load_dotenv
import websockets

from .config import Config
from .websocket_manager import WebSocketManager

load_dotenv()


class WebSocketManager:
    """Manages WebSocket connections, authentication, and rate limiting."""

    def __init__(
        self, ws_url: str, api_key: str, api_secret: str, rate_limit: int, config: Any
    ):
        self.ws_url = ws_url
        self.api_key = api_key
        self.api_secret = api_secret
        self.rate_limit = rate_limit
        self.config = config
        self.ws: Optional[WebSocketClientProtocol] = None
        self._lock = asyncio.Lock()
        self._last_message_time = 0
        self._rate_limit_interval = 1.0 / rate_limit if rate_limit > 0 else 0

    async def __aenter__(self):
        self.ws = await websockets.connect(self.ws_url)
        return self.ws

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.close()

    async def send_message(
        self, message: str, ws: Optional[WebSocketClientProtocol] = None
    ):
        async with self._lock:
            now = time.time()
            elapsed = now - self._last_message_time
            if elapsed < self._rate_limit_interval:
                await asyncio.sleep(self._rate_limit_interval - elapsed)
            if ws is None:
                ws = self.ws
            if ws is not None:
                await ws.send(message)
                self._last_message_time = time.time()
            else:
                logging.error("WebSocket is not connected.")

    async def receive_message(
        self, ws: Optional[WebSocketClientProtocol] = None
    ) -> Optional[str]:
        if ws is None:
            ws = self.ws
        if ws is not None:
            try:
                message = await ws.recv()
                return message
            except websockets.exceptions.ConnectionClosed as e:
                logging.error(f"WebSocket connection closed: {e}")
                return None
        else:
            logging.error("WebSocket is not connected.")
            return None

    async def close(self):
        if self.ws is not None:
            await self.ws.close()
            self.ws = None

    def _generate_signature(self, params: Dict[str, Any]) -> str:
        sorted_params = sorted(params.items())
        encoded_params = '&'.join(f"{k}={v}" for k, v in sorted_params)
        message = encoded_params.encode('utf-8')
        secret = self.api_secret.encode('utf-8')
        signature = hmac.new(secret, message, hashlib.sha256).hexdigest()
        return signature
